(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{446:function(a,_,v){"use strict";v.r(_);var e=v(30),l=Object(e.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql"}},[a._v("#")]),a._v(" SQL")]),a._v(" "),_("h3",{attrs:{id:"按功能划分-sql-语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#按功能划分-sql-语言"}},[a._v("#")]),a._v(" 按功能划分 SQL 语言")]),a._v(" "),_("ol",[_("li",[a._v("DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。")]),a._v(" "),_("li",[a._v("DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。")]),a._v(" "),_("li",[a._v("DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。")]),a._v(" "),_("li",[a._v("DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道。因此学会编写正确且高效的查询语句，是学习的重点。")])]),a._v(" "),_("h3",{attrs:{id:"了解-sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#了解-sql"}},[a._v("#")]),a._v(" 了解 SQL")]),a._v(" "),_("p",[a._v("SQL 是我们与 DBMS 交流的语言，我们在创建 DBMS(Database Management System:数据库管理系统) 之前，还需要对它进行设计，对于 RDBMS（Relational Database Management System:关系数据库管理系统） 来说采用的是 ER 图（Entity Relationship Diagram），即实体 - 关系图的方式进行设计。")]),a._v(" "),_("p",[a._v("ER 图评审通过后，我们再用 SQL 语句或者可视化管理工具（如 Navicat）创建数据表。")]),a._v(" "),_("p",[a._v("实体 - 关系图有什么用呢？它是我们用来描述现实世界的概念模型，在这个模型中有 3 个\n要素：实体、属性、关系。实体就是我们要管理的对象，属性是标识每个实体的属性，关系则是对象之间的关系。")]),a._v(" "),_("p",[a._v("创建完数据表之后，我们就可以用 SQL 操作了。")]),a._v(" "),_("p",[a._v("SQL 推荐采用统一的书写规范：")]),a._v(" "),_("ol",[_("li",[a._v("表名、表别名、字段名、字段别名等小写；")]),a._v(" "),_("li",[a._v("SQL 保留字、函数名、绑定变量等大写。")]),a._v(" "),_("li",[a._v("数据表的字段名推荐采用下划线命名，如 role_main。")])]),a._v(" "),_("h3",{attrs:{id:"sql-是如何被执行的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql-是如何被执行的"}},[a._v("#")]),a._v(" SQL 是如何被执行的")]),a._v(" "),_("h4",{attrs:{id:"oracle-中的-sql-是如何执行的-什么是硬解析和软解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oracle-中的-sql-是如何执行的-什么是硬解析和软解析"}},[a._v("#")]),a._v(" Oracle 中的 SQL 是如何执行的，什么是硬解析和软解析？")]),a._v(" "),_("p",[_("img",{attrs:{src:"/images/backend/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png",alt:""}})]),a._v(" "),_("ol",[_("li",[a._v("语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。")]),a._v(" "),_("li",[a._v("语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。")]),a._v(" "),_("li",[a._v("权限检查：看用户是否具备访问该数据的权限。")]),a._v(" "),_("li",[a._v("共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是"),_("strong",[a._v("缓存 SQL 语句和该语句的执行计划")]),a._v("。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。")]),a._v(" "),_("li",[a._v("优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。")]),a._v(" "),_("li",[a._v("执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。")])]),a._v(" "),_("p",[a._v("库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。")]),a._v(" "),_("p",[a._v("查询 ID："),_("code",[a._v("SQL> select * from player where player_id = 10001;")])]),a._v(" "),_("p",[a._v("绑定变量："),_("code",[a._v("SQL> select * from player where player_id = :player_id;")])]),a._v(" "),_("p",[a._v("这两个查询语句的效率在 Oracle 中是完全不同的。如果在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行划,也就是软解析。")]),a._v(" "),_("h4",{attrs:{id:"mysql-中的-sql-是如何执行的-mysql-的体系结构又是怎样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-中的-sql-是如何执行的-mysql-的体系结构又是怎样的"}},[a._v("#")]),a._v(" MySQL 中的 SQL 是如何执行的，MySQL 的体系结构又是怎样的？")]),a._v(" "),_("p",[a._v("MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：")]),a._v(" "),_("p",[_("img",{attrs:{src:"/images/backend/mySql.png",alt:""}})]),a._v(" "),_("p",[a._v("MySQL 由三层组成：")]),a._v(" "),_("ol",[_("li",[a._v("连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；")]),a._v(" "),_("li",[a._v("SQL 层：对 SQL 语句进行查询处理；")]),a._v(" "),_("li",[a._v("存储引擎层：与数据库文件打交道，负责数据的存储和读取。")])]),a._v(" "),_("p",[a._v("❓ 在 MySQL 中对一条 SQL 语句的执行时间进行分析")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("开启 profiling,0 代表关闭，1 为开启："),_("code",[a._v("mysql> select @@profiling;")]),a._v(";"),_("code",[a._v("mysql> set profiling=1;")])])]),a._v(" "),_("li",[_("p",[a._v("执行 SQL 查询："),_("code",[a._v("mysql> select * from wucai.heros;")])])]),a._v(" "),_("li",[_("p",[a._v("查看会话产生的所有 profiles："),_("code",[a._v("show profiles;")]),a._v("\n或查询指定的 Query ID："),_("code",[a._v("mysql> show profile for query 2;")])])])]),a._v(" "),_("h4",{attrs:{id:"什么是存储引擎-mysql-的存储引擎都有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是存储引擎-mysql-的存储引擎都有哪些"}},[a._v("#")]),a._v(" 什么是存储引擎，MySQL 的存储引擎都有哪些？")]),a._v(" "),_("p",[a._v("与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：")]),a._v(" "),_("ol",[_("li",[a._v("InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。")]),a._v(" "),_("li",[a._v("MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。")]),a._v(" "),_("li",[a._v("Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。")]),a._v(" "),_("li",[a._v("NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。")]),a._v(" "),_("li",[a._v("Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。")])]),a._v(" "),_("h3",{attrs:{id:"ddl"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ddl"}},[a._v("#")]),a._v(" DDL")]),a._v(" "),_("h4",{attrs:{id:"ddl-定义了数据库的结构和数据表的结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ddl-定义了数据库的结构和数据表的结构"}},[a._v("#")]),a._v(" DDL 定义了数据库的结构和数据表的结构")]),a._v(" "),_("h5",{attrs:{id:"了解-ddl-的基础语法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#了解-ddl-的基础语法"}},[a._v("#")]),a._v(" 了解 DDL 的基础语法")]),a._v(" "),_("p",[a._v("在执行 DDL 的时候，不需要 COMMIT，就可以完成执行任务。")]),a._v(" "),_("p",[a._v("增删改:"),_("code",[a._v("CREATE")]),a._v(","),_("code",[a._v("DROP")]),a._v(","),_("code",[a._v("ALTER")])]),a._v(" "),_("p",[a._v("1️⃣ 定义数据库")]),a._v(" "),_("p",[a._v("创建一个名为 nba 的数据库："),_("code",[a._v("CREATE DATABASE nba;")])]),a._v(" "),_("p",[a._v("删除一个名为 nba 的数据库："),_("code",[a._v("DROP DATABASE nba;")])]),a._v(" "),_("p",[a._v("2️⃣ 定义数据表")]),a._v(" "),_("p",[a._v("创建表结构："),_("code",[a._v("CREATE TABLE table_name")])]),a._v(" "),_("p",[a._v("创建示例：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("CREATE TABLE player (\nplayer_id int(11) NOT NULL AUTO_INCREMENT,\nplayer_name varchar(255) NOT NULL\n);\n")])])]),_("p",[a._v("解释：创建一个表名为 player 的表，，里面有两个字段，一个是 player_id，它是 int 类型，另一个 player_name 字段是 varchar(255)类型。这两个字段都不为空，且 player_id 是递增的。")]),a._v(" "),_("p",[_("code",[a._v("int(11)")]),a._v("：整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度")]),a._v(" "),_("p",[_("code",[a._v("varchar(255)")]),a._v("：最大长度为 255 的可变字符串类型")]),a._v(" "),_("p",[_("code",[a._v("NOT NULL")]),a._v("：整个字段不能是空值，是一种数据约束")]),a._v(" "),_("p",[_("code",[a._v("AUTO_INCREMENT")]),a._v("：主键自动增长")]),a._v(" "),_("p",[a._v("实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具**（Navicat）**来创建和操作数据库和数据表。")]),a._v(" "),_("p",[a._v("3️⃣ 修改表结构")]),a._v(" "),_("p",[a._v("在创建表结构之后，我们还可以对表结构进行修改，虽然直接使用 Navicat 可以保证重新导出的数据表就是最新的，但也有必要了解如何使用 DDL 命令来完成表结构的修改。")]),a._v(" "),_("p",[a._v("添加字段(age 字段)："),_("code",[a._v("ALTER TABLE player ADD (age int(11));")])]),a._v(" "),_("p",[a._v("【❓ 存疑】修改字段名(player--\x3e player_age)："),_("code",[a._v("ALTER TABLE player RENAME COLUMN age to player_age")])]),a._v(" "),_("p",[a._v("修改字段数据类型(player_age 数据类型--\x3efloat(3,1))："),_("code",[a._v("ALTER TABLE player MODIFY (player_age float(3,1));")])]),a._v(" "),_("p",[a._v("删除字段(player_age)："),_("code",[a._v("ALTER TABLE player DROP COLUMN player_age;")])]),a._v(" "),_("h4",{attrs:{id:"使用-ddl-定义数据表时-都有哪些约束性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-ddl-定义数据表时-都有哪些约束性"}},[a._v("#")]),a._v(" 使用 DDL 定义数据表时，都有哪些约束性")]),a._v(" "),_("p",[a._v("1️⃣ 主键约束")]),a._v(" "),_("p",[a._v("主键起的作用是唯一标识一条记录，不能重复，不能为空，即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。")]),a._v(" "),_("p",[a._v("2️⃣ 外键约束")]),a._v(" "),_("p",[a._v("外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。")]),a._v(" "),_("p",[a._v("【示例】：player_id 在 player 表中是主键，如果想设置一个球员比分表即 player_score，就可以在 player_score 中设 player_id 为外键，关联到 player 表中。")]),a._v(" "),_("p",[a._v("3️⃣ 字段约束")]),a._v(" "),_("ul",[_("li",[a._v("唯一性约束：唯一性约束表明字段在表中的数值是唯一的。唯一性约束和普通索引（NORMAL INDEX）之间是有区别的。唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。")]),a._v(" "),_("li",[a._v("NOT NULL 约束：表明该字段不应为空，必须有取值。")]),a._v(" "),_("li",[a._v("DEFAULT：表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。")]),a._v(" "),_("li",[a._v("CHECK 约束：检查特定字段取值范围的有效性，CHECK 约束的结果不能为 FALSE。")])]),a._v(" "),_("h4",{attrs:{id:"使用-ddl-设计数据库时-都有哪些重要原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-ddl-设计数据库时-都有哪些重要原则"}},[a._v("#")]),a._v(" 使用 DDL 设计数据库时，都有哪些重要原则")]),a._v(" "),_("ul",[_("li",[a._v("数据表的个数越少越好。RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图（Entity Relationship Diagram），数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。")]),a._v(" "),_("li",[a._v("数据表中的字段个数越少越好。字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。")]),a._v(" "),_("li",[a._v("数据表中联合主键的字段个数越少越好。设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。")]),a._v(" "),_("li")]),a._v(" "),_("h3",{attrs:{id:"sql-检索数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql-检索数据"}},[a._v("#")]),a._v(" SQL 检索数据")])])}),[],!1,null,null,null);_.default=l.exports}}]);