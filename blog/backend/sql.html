<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SQL | tayce&#39;s library</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/logo.jpg">
    <link rel="stylesheet" href="/styles/index.css">
    <meta name="description" content="移动的图书馆">
    
    <link rel="preload" href="/assets/css/0.styles.b67afc4c.css" as="style"><link rel="preload" href="/assets/js/app.f9c3f30c.js" as="script"><link rel="preload" href="/assets/js/2.b7af9bcd.js" as="script"><link rel="preload" href="/assets/js/1.6eac4c2f.js" as="script"><link rel="preload" href="/assets/js/29.de5d9f07.js" as="script"><link rel="prefetch" href="/assets/js/10.cac3315f.js"><link rel="prefetch" href="/assets/js/11.22aa9600.js"><link rel="prefetch" href="/assets/js/12.2a5384fa.js"><link rel="prefetch" href="/assets/js/13.820e2af8.js"><link rel="prefetch" href="/assets/js/14.11b318eb.js"><link rel="prefetch" href="/assets/js/15.4359e6dc.js"><link rel="prefetch" href="/assets/js/16.42eda455.js"><link rel="prefetch" href="/assets/js/17.3e808b6b.js"><link rel="prefetch" href="/assets/js/18.7130fbcf.js"><link rel="prefetch" href="/assets/js/19.58d29412.js"><link rel="prefetch" href="/assets/js/20.4da7041e.js"><link rel="prefetch" href="/assets/js/21.a6bf00fc.js"><link rel="prefetch" href="/assets/js/22.4de2c7de.js"><link rel="prefetch" href="/assets/js/23.a4fb8c1e.js"><link rel="prefetch" href="/assets/js/24.c3aa6e5e.js"><link rel="prefetch" href="/assets/js/25.519bcaa7.js"><link rel="prefetch" href="/assets/js/26.908b218a.js"><link rel="prefetch" href="/assets/js/27.ead5efbd.js"><link rel="prefetch" href="/assets/js/28.f0099a76.js"><link rel="prefetch" href="/assets/js/3.3d769f85.js"><link rel="prefetch" href="/assets/js/30.8a485245.js"><link rel="prefetch" href="/assets/js/31.229bf691.js"><link rel="prefetch" href="/assets/js/32.9bb2b8d8.js"><link rel="prefetch" href="/assets/js/33.41b2fb5b.js"><link rel="prefetch" href="/assets/js/34.7539eb47.js"><link rel="prefetch" href="/assets/js/35.47144861.js"><link rel="prefetch" href="/assets/js/36.3f061274.js"><link rel="prefetch" href="/assets/js/37.c3577050.js"><link rel="prefetch" href="/assets/js/38.78ad621f.js"><link rel="prefetch" href="/assets/js/39.d5eafe9c.js"><link rel="prefetch" href="/assets/js/4.b09b1dd9.js"><link rel="prefetch" href="/assets/js/40.8ce3c438.js"><link rel="prefetch" href="/assets/js/41.0fe59981.js"><link rel="prefetch" href="/assets/js/42.aad61fb2.js"><link rel="prefetch" href="/assets/js/43.6b970b53.js"><link rel="prefetch" href="/assets/js/44.0f85b437.js"><link rel="prefetch" href="/assets/js/45.3f668e4c.js"><link rel="prefetch" href="/assets/js/46.e4f24bc3.js"><link rel="prefetch" href="/assets/js/47.346e64d5.js"><link rel="prefetch" href="/assets/js/48.c4d9666b.js"><link rel="prefetch" href="/assets/js/49.57ec0363.js"><link rel="prefetch" href="/assets/js/5.d2116699.js"><link rel="prefetch" href="/assets/js/50.0c8a5db9.js"><link rel="prefetch" href="/assets/js/51.8782a2cd.js"><link rel="prefetch" href="/assets/js/52.6f1a07d1.js"><link rel="prefetch" href="/assets/js/53.4b57668e.js"><link rel="prefetch" href="/assets/js/54.a926e336.js"><link rel="prefetch" href="/assets/js/55.ea5fe790.js"><link rel="prefetch" href="/assets/js/56.310bbcfd.js"><link rel="prefetch" href="/assets/js/57.6d8b5be5.js"><link rel="prefetch" href="/assets/js/58.ec9d1474.js"><link rel="prefetch" href="/assets/js/59.7fd99801.js"><link rel="prefetch" href="/assets/js/6.dc14cda6.js"><link rel="prefetch" href="/assets/js/60.dcb5d4d7.js"><link rel="prefetch" href="/assets/js/7.c4829e31.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.e1f8ac62.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b67afc4c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tayce's library</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="sql"><a href="#sql" class="header-anchor">#</a> SQL</h2> <h3 id="按功能划分-sql-语言"><a href="#按功能划分-sql-语言" class="header-anchor">#</a> 按功能划分 SQL 语言</h3> <ol><li>DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li> <li>DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li> <li>DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</li> <li>DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道。因此学会编写正确且高效的查询语句，是学习的重点。</li></ol> <h3 id="了解-sql"><a href="#了解-sql" class="header-anchor">#</a> 了解 SQL</h3> <p>SQL 是我们与 DBMS 交流的语言，我们在创建 DBMS(Database Management System:数据库管理系统) 之前，还需要对它进行设计，对于 RDBMS（Relational Database Management System:关系数据库管理系统） 来说采用的是 ER 图（Entity Relationship Diagram），即实体 - 关系图的方式进行设计。</p> <p>ER 图评审通过后，我们再用 SQL 语句或者可视化管理工具（如 Navicat）创建数据表。</p> <p>实体 - 关系图有什么用呢？它是我们用来描述现实世界的概念模型，在这个模型中有 3 个
要素：实体、属性、关系。实体就是我们要管理的对象，属性是标识每个实体的属性，关系则是对象之间的关系。</p> <p>创建完数据表之后，我们就可以用 SQL 操作了。</p> <p>SQL 推荐采用统一的书写规范：</p> <ol><li>表名、表别名、字段名、字段别名等小写；</li> <li>SQL 保留字、函数名、绑定变量等大写。</li> <li>数据表的字段名推荐采用下划线命名，如 role_main。</li></ol> <h3 id="sql-是如何被执行的"><a href="#sql-是如何被执行的" class="header-anchor">#</a> SQL 是如何被执行的</h3> <h4 id="oracle-中的-sql-是如何执行的-什么是硬解析和软解析"><a href="#oracle-中的-sql-是如何执行的-什么是硬解析和软解析" class="header-anchor">#</a> Oracle 中的 SQL 是如何执行的，什么是硬解析和软解析？</h4> <p><img src="/images/backend/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt=""></p> <ol><li>语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li> <li>语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li> <li>权限检查：看用户是否具备访问该数据的权限。</li> <li>共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是<strong>缓存 SQL 语句和该语句的执行计划</strong>。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</li> <li>优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li> <li>执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</li></ol> <p>库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p> <p>查询 ID：<code>SQL&gt; select * from player where player_id = 10001;</code></p> <p>绑定变量：<code>SQL&gt; select * from player where player_id = :player_id;</code></p> <p>这两个查询语句的效率在 Oracle 中是完全不同的。如果在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行划,也就是软解析。</p> <h4 id="mysql-中的-sql-是如何执行的-mysql-的体系结构又是怎样的"><a href="#mysql-中的-sql-是如何执行的-mysql-的体系结构又是怎样的" class="header-anchor">#</a> MySQL 中的 SQL 是如何执行的，MySQL 的体系结构又是怎样的？</h4> <p>MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：</p> <p><img src="/images/backend/mySql.png" alt=""></p> <p>MySQL 由三层组成：</p> <ol><li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li> <li>SQL 层：对 SQL 语句进行查询处理；</li> <li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol> <p>❓ 在 MySQL 中对一条 SQL 语句的执行时间进行分析</p> <ol><li><p>开启 profiling,0 代表关闭，1 为开启：<code>mysql&gt; select @@profiling;</code>;<code>mysql&gt; set profiling=1;</code></p></li> <li><p>执行 SQL 查询：<code>mysql&gt; select * from wucai.heros;</code></p></li> <li><p>查看会话产生的所有 profiles：<code>show profiles;</code>
或查询指定的 Query ID：<code>mysql&gt; show profile for query 2;</code></p></li></ol> <h4 id="什么是存储引擎-mysql-的存储引擎都有哪些"><a href="#什么是存储引擎-mysql-的存储引擎都有哪些" class="header-anchor">#</a> 什么是存储引擎，MySQL 的存储引擎都有哪些？</h4> <p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p> <ol><li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li> <li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li> <li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li> <li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li> <li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li></ol> <h3 id="ddl"><a href="#ddl" class="header-anchor">#</a> DDL</h3> <h4 id="ddl-定义了数据库的结构和数据表的结构"><a href="#ddl-定义了数据库的结构和数据表的结构" class="header-anchor">#</a> DDL 定义了数据库的结构和数据表的结构</h4> <h5 id="了解-ddl-的基础语法"><a href="#了解-ddl-的基础语法" class="header-anchor">#</a> 了解 DDL 的基础语法</h5> <p>在执行 DDL 的时候，不需要 COMMIT，就可以完成执行任务。</p> <p>增删改:<code>CREATE</code>,<code>DROP</code>,<code>ALTER</code></p> <p>1️⃣ 定义数据库</p> <p>创建一个名为 nba 的数据库：<code>CREATE DATABASE nba;</code></p> <p>删除一个名为 nba 的数据库：<code>DROP DATABASE nba;</code></p> <p>2️⃣ 定义数据表</p> <p>创建表结构：<code>CREATE TABLE table_name</code></p> <p>创建示例：</p> <div class="language- extra-class"><pre class="language-text"><code>CREATE TABLE player (
player_id int(11) NOT NULL AUTO_INCREMENT,
player_name varchar(255) NOT NULL
);
</code></pre></div><p>解释：创建一个表名为 player 的表，，里面有两个字段，一个是 player_id，它是 int 类型，另一个 player_name 字段是 varchar(255)类型。这两个字段都不为空，且 player_id 是递增的。</p> <p><code>int(11)</code>：整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度</p> <p><code>varchar(255)</code>：最大长度为 255 的可变字符串类型</p> <p><code>NOT NULL</code>：整个字段不能是空值，是一种数据约束</p> <p><code>AUTO_INCREMENT</code>：主键自动增长</p> <p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具**（Navicat）**来创建和操作数据库和数据表。</p> <p>3️⃣ 修改表结构</p> <p>在创建表结构之后，我们还可以对表结构进行修改，虽然直接使用 Navicat 可以保证重新导出的数据表就是最新的，但也有必要了解如何使用 DDL 命令来完成表结构的修改。</p> <p>添加字段(age 字段)：<code>ALTER TABLE player ADD (age int(11));</code></p> <p>【❓ 存疑】修改字段名(player--&gt; player_age)：<code>ALTER TABLE player RENAME COLUMN age to player_age</code></p> <p>修改字段数据类型(player_age 数据类型--&gt;float(3,1))：<code>ALTER TABLE player MODIFY (player_age float(3,1));</code></p> <p>删除字段(player_age)：<code>ALTER TABLE player DROP COLUMN player_age;</code></p> <h4 id="使用-ddl-定义数据表时-都有哪些约束性"><a href="#使用-ddl-定义数据表时-都有哪些约束性" class="header-anchor">#</a> 使用 DDL 定义数据表时，都有哪些约束性</h4> <p>1️⃣ 主键约束</p> <p>主键起的作用是唯一标识一条记录，不能重复，不能为空，即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。</p> <p>2️⃣ 外键约束</p> <p>外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。</p> <p>【示例】：player_id 在 player 表中是主键，如果想设置一个球员比分表即 player_score，就可以在 player_score 中设 player_id 为外键，关联到 player 表中。</p> <p>3️⃣ 字段约束</p> <ul><li>唯一性约束：唯一性约束表明字段在表中的数值是唯一的。唯一性约束和普通索引（NORMAL INDEX）之间是有区别的。唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。</li> <li>NOT NULL 约束：表明该字段不应为空，必须有取值。</li> <li>DEFAULT：表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。</li> <li>CHECK 约束：检查特定字段取值范围的有效性，CHECK 约束的结果不能为 FALSE。</li></ul> <h4 id="使用-ddl-设计数据库时-都有哪些重要原则"><a href="#使用-ddl-设计数据库时-都有哪些重要原则" class="header-anchor">#</a> 使用 DDL 设计数据库时，都有哪些重要原则</h4> <ul><li>数据表的个数越少越好。RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图（Entity Relationship Diagram），数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</li> <li>数据表中的字段个数越少越好。字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</li> <li>数据表中联合主键的字段个数越少越好。设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</li> <li></li></ul> <h3 id="sql-检索数据"><a href="#sql-检索数据" class="header-anchor">#</a> SQL 检索数据</h3></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f9c3f30c.js" defer></script><script src="/assets/js/2.b7af9bcd.js" defer></script><script src="/assets/js/1.6eac4c2f.js" defer></script><script src="/assets/js/29.de5d9f07.js" defer></script>
  </body>
</html>
