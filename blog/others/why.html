<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Q1.标记清除算法是如何处理循环引用的 ❓ | tayce&#39;s library</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/logo.jpg">
    <link rel="stylesheet" href="/styles/index.css">
    <meta name="description" content="移动的图书馆">
    
    <link rel="preload" href="/assets/css/0.styles.b67afc4c.css" as="style"><link rel="preload" href="/assets/js/app.f9c3f30c.js" as="script"><link rel="preload" href="/assets/js/2.b7af9bcd.js" as="script"><link rel="preload" href="/assets/js/1.6eac4c2f.js" as="script"><link rel="preload" href="/assets/js/51.8782a2cd.js" as="script"><link rel="prefetch" href="/assets/js/10.cac3315f.js"><link rel="prefetch" href="/assets/js/11.22aa9600.js"><link rel="prefetch" href="/assets/js/12.2a5384fa.js"><link rel="prefetch" href="/assets/js/13.820e2af8.js"><link rel="prefetch" href="/assets/js/14.11b318eb.js"><link rel="prefetch" href="/assets/js/15.4359e6dc.js"><link rel="prefetch" href="/assets/js/16.42eda455.js"><link rel="prefetch" href="/assets/js/17.3e808b6b.js"><link rel="prefetch" href="/assets/js/18.7130fbcf.js"><link rel="prefetch" href="/assets/js/19.58d29412.js"><link rel="prefetch" href="/assets/js/20.4da7041e.js"><link rel="prefetch" href="/assets/js/21.a6bf00fc.js"><link rel="prefetch" href="/assets/js/22.4de2c7de.js"><link rel="prefetch" href="/assets/js/23.a4fb8c1e.js"><link rel="prefetch" href="/assets/js/24.c3aa6e5e.js"><link rel="prefetch" href="/assets/js/25.519bcaa7.js"><link rel="prefetch" href="/assets/js/26.908b218a.js"><link rel="prefetch" href="/assets/js/27.ead5efbd.js"><link rel="prefetch" href="/assets/js/28.f0099a76.js"><link rel="prefetch" href="/assets/js/29.de5d9f07.js"><link rel="prefetch" href="/assets/js/3.3d769f85.js"><link rel="prefetch" href="/assets/js/30.8a485245.js"><link rel="prefetch" href="/assets/js/31.229bf691.js"><link rel="prefetch" href="/assets/js/32.9bb2b8d8.js"><link rel="prefetch" href="/assets/js/33.41b2fb5b.js"><link rel="prefetch" href="/assets/js/34.7539eb47.js"><link rel="prefetch" href="/assets/js/35.47144861.js"><link rel="prefetch" href="/assets/js/36.3f061274.js"><link rel="prefetch" href="/assets/js/37.c3577050.js"><link rel="prefetch" href="/assets/js/38.78ad621f.js"><link rel="prefetch" href="/assets/js/39.d5eafe9c.js"><link rel="prefetch" href="/assets/js/4.b09b1dd9.js"><link rel="prefetch" href="/assets/js/40.8ce3c438.js"><link rel="prefetch" href="/assets/js/41.0fe59981.js"><link rel="prefetch" href="/assets/js/42.aad61fb2.js"><link rel="prefetch" href="/assets/js/43.6b970b53.js"><link rel="prefetch" href="/assets/js/44.0f85b437.js"><link rel="prefetch" href="/assets/js/45.3f668e4c.js"><link rel="prefetch" href="/assets/js/46.e4f24bc3.js"><link rel="prefetch" href="/assets/js/47.346e64d5.js"><link rel="prefetch" href="/assets/js/48.c4d9666b.js"><link rel="prefetch" href="/assets/js/49.57ec0363.js"><link rel="prefetch" href="/assets/js/5.d2116699.js"><link rel="prefetch" href="/assets/js/50.0c8a5db9.js"><link rel="prefetch" href="/assets/js/52.6f1a07d1.js"><link rel="prefetch" href="/assets/js/53.4b57668e.js"><link rel="prefetch" href="/assets/js/54.a926e336.js"><link rel="prefetch" href="/assets/js/55.ea5fe790.js"><link rel="prefetch" href="/assets/js/56.310bbcfd.js"><link rel="prefetch" href="/assets/js/57.6d8b5be5.js"><link rel="prefetch" href="/assets/js/58.ec9d1474.js"><link rel="prefetch" href="/assets/js/59.7fd99801.js"><link rel="prefetch" href="/assets/js/6.dc14cda6.js"><link rel="prefetch" href="/assets/js/60.dcb5d4d7.js"><link rel="prefetch" href="/assets/js/7.c4829e31.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.e1f8ac62.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b67afc4c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tayce's library</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="q1-标记清除算法是如何处理循环引用的-❓"><a href="#q1-标记清除算法是如何处理循环引用的-❓" class="header-anchor">#</a> Q1.标记清除算法是如何处理循环引用的 ❓</h2> <p>1.引用计数算法及问题</p> <p>垃圾回收器会为每个对象维护一个引用计数器，记录当前对象被引用的次数。当一个对象的引用被释放时，引用计数器减一。当<strong>引用计数器为 0</strong>时，表示该对象<strong>不再被引用</strong>，即为垃圾对象，垃圾回收器会立即回收并释放其占用的内存空间。</p> <p>‼️ 引用计数算法无法处理循环引用的情况，可能会导致内存泄漏：</p> <blockquote><p>举个例子：假设对象 A，包含一个指向对象 B 的引用，而对象 B 也包含一个指向对象 A 的引用。此时，由于对象 A 和 B 互相引用的次数不为 0，垃圾回收器就无法清除这两个对象，导致内存泄漏。</p></blockquote> <p><strong>标记清除算法的处理方式</strong></p> <p>在标记阶段，垃圾回收器会将循环引用的对象标记为“可达”，并且在遍历过程中<strong>不会重复标记</strong>已经被标记过的对象。</p> <p>在清除阶段，由于循环引用的对象被标记为“可达”，因此不会被清除，从而保证了循环引用的正确处理。</p> <blockquote><p>举个例子：假设对象 A，包含一个指向对象 B 的引用，而对象 B 也包含一个指向对象 A 的引用。在标记阶段，垃圾回收器会从<strong>根对象</strong>开始遍历内存中的所有对象，标记对象 A 和 B 为可达对象，并且标记它们是循环引用的对象。对于循环引用的情况，只要有一个对象不再被根或其他活动对象所引用，垃圾收集器就会清理这个对象，包括它引用的循环中的另一个对象。</p></blockquote> <h2 id="q2-为什么尾递归可以避免栈溢出-❓"><a href="#q2-为什么尾递归可以避免栈溢出-❓" class="header-anchor">#</a> Q2.为什么尾递归可以避免栈溢出 ❓</h2> <p><strong>尾递归的概念</strong>：在函数的最后一步调用自身，而不是在调用后还有其他操作。</p> <p><strong>尾递归的优势</strong>：尾递归可以有效地避免栈溢出的风险，因为它不需要保存每次调用的上下文，只需要保留一个栈帧即可。尾递归也可以提高递归的性能，因为它减少了函数调用的开销。</p> <p><strong>尾递归和普通递归的区别</strong>：递归调用发生的位置不同。在普通递归中，递归函数调用在递归函数的末尾，而在尾递归中，递归函数调用是函数的最后一个操作。</p> <p><strong>注意 ⚠️</strong>：尾递归优化只有在严格模式（strict mode）下才能生效。在非严格模式下，尾递归调用仍然会导致堆栈溢出。</p> <p>代码示例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通递归</span>
<span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 尾递归可以被js解释器优化成循环</span>
<span class="token keyword">function</span> <span class="token function">fibonacciTail</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fibonacciTail</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q3-如何分析内存或排查内存泄漏-❓"><a href="#q3-如何分析内存或排查内存泄漏-❓" class="header-anchor">#</a> Q3.如何分析内存或排查内存泄漏 ❓</h2> <p><strong>Memory(chrome devtools)</strong></p> <p><img src="/images/js-img/memory.png" alt=""></p> <p><img src="/images/js-img/performance.png" alt=""></p> <p>注意：打开 Chrome 的无痕模式，避免 Chrome 插件影响测试内存占用情况</p> <h2 id="q4-5-个-6-和-1、2、3、4、5-的问题-❓"><a href="#q4-5-个-6-和-1、2、3、4、5-的问题-❓" class="header-anchor">#</a> Q4.5 个 6 和 1、2、3、4、5 的问题 ❓</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 6 6 6 6 6</span>
</code></pre></div><p>对输出结果的理解：</p> <p>1️⃣ <code>setTimeout</code>是宏任务，由于 js 中单线程的 eventloop 机制，在主线程同步任务执行完之后才去执行宏任务，因此循环结束后<code>setTimeout</code>的回调才依次执行。</p> <p>2️⃣ <code>setTimeout</code>函数也是一种闭包，想上找 父级作用域链是<code>window</code>,变量 i 是<code>window</code>的全局变量，开始执行<code>setTimeout</code>之前变量 i 已经是 6，所以最后的输出都是 6</p> <p>如何按顺序依次输出 1、2、3、4、5 呢 ❓</p> <p>方式一：立即执行函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方式二：使用<code>let</code> 块级作用域（相当于匿名函数）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方式三：<code>setTimeout</code>第三个参数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span>
    i
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q5-为什么-eval-、with-被认为是不推荐使用的特性-❓"><a href="#q5-为什么-eval-、with-被认为是不推荐使用的特性-❓" class="header-anchor">#</a> Q5.为什么 <code>eval()</code>、<code>with()</code>被认为是不推荐使用的特性 ❓</h2> <ul><li><code>eval()</code>：可以执行传递给它的字符串作为 JS 代码并将结果插入到原位置，<strong>容易被恶意植入</strong>。</li></ul> <p>示例: <code>eval(&quot;x=10;y=20;document.write(x*y)&quot;);</code></p> <ul><li><code>with()</code>：允许在指定的对象作用域中执行代码块，可以省略对象名称的重复引用。</li></ul> <p>示例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 30</span>
<span class="token punctuation">}</span>
</code></pre></div><p>性能问题</p> <p>①js 引擎会在编译阶段进行性能优化，其中部分优化依赖于对词法作用域的静态分析；</p> <p>②eval 函数和 with 关键字会欺骗词法作用域（eval 动态修改，with 凭空创建新的），从而导致词法作用域中变量和函数的定义位置无法事先确定；</p> <p>③js 引擎发现代码中的 eval 和 with 后，会判别无法事先做优化，故直接放弃</p> <h2 id="q6-如果对一个函数进行多次-bind-函数的-this-会如何改变-❓"><a href="#q6-如果对一个函数进行多次-bind-函数的-this-会如何改变-❓" class="header-anchor">#</a> Q6.如果对一个函数进行多次 <code>bind</code> ，函数的 this 会如何改变 ❓</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// fn.bind().bind(a) 等于</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>结论：不论对函数 <code>bind</code> 了多少次， fn 中的 <code>this</code> 永远由第一次 bind 决定。</p> <h2 id="q6-call、apply、bind-原理及实现-❓"><a href="#q6-call、apply、bind-原理及实现-❓" class="header-anchor">#</a> Q6.<code>call</code>、<code>apply</code>、<code>bind</code> 原理及实现 ❓</h2> <h3 id="call"><a href="#call" class="header-anchor">#</a> <code>call</code></h3> <p>先来看看<code>call</code>的基础使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
</code></pre></div><h4 id="call-做了什么"><a href="#call-做了什么" class="header-anchor">#</a> call 做了什么？</h4> <blockquote><p>1.将函数设为对象的属性</p> <p>2.执行和删除这个函数</p> <p>3.指定 this 到函数并传入给定参数,执行函数</p> <p>4.如果不传入参数，默认指向 window</p></blockquote> <p>如果以上文字看不懂，请看如下代码 ⬇️</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="实现-call方法"><a href="#实现-call方法" class="header-anchor">#</a> 实现 <code>call</code>方法</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fnKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唯一属性名，不会出现属性名的覆盖</span>
  <span class="token comment">// context表示call传入的this</span>
  <span class="token comment">// this表示调用call的函数fn</span>
  context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将fn函数设为 context 的属性</span>

  <span class="token comment">// fn内部this指向context 相当于 context.fn()</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 清理fn</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="apply"><a href="#apply" class="header-anchor">#</a> <code>apply</code></h3> <h4 id="实现-apply方法"><a href="#实现-apply方法" class="header-anchor">#</a> 实现 <code>apply</code>方法</h4> <p>apply 第二个参数是 Array,而 call 是将一个个传入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>args <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'params must be array'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> fnKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="bind"><a href="#bind" class="header-anchor">#</a> <code>bind</code></h3> <p>当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，
之后的一序列参数将会在传递的实参前传入作为它的参数。</p> <h4 id="bind基础使用"><a href="#bind基础使用" class="header-anchor">#</a> <code>bind</code>基础使用</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1st</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2nd</span>
<span class="token punctuation">}</span>
<span class="token comment">// 我们将foo bind到{a: 1}</span>
<span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'1st'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token string">'2nd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="bind的实现"><a href="#bind的实现" class="header-anchor">#</a> <code>bind</code>的实现</h4> <p>考虑两点：</p> <p>1.对于普通函数，绑定<code>this</code>指向</p> <p>2.对于构造函数，要保证原函数的原型对象上的属性不能丢失</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// this表示调用bind的函数</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">//  fn.bind(obj) self就是fn</span>

  <span class="token comment">// this instanceof fBound为true时，表明为构造函数：new func.bind(obj)</span>
  <span class="token comment">// 如果是普通函数，this默认指向window，如果为false时，将绑定函数的this指向context</span>
  <span class="token keyword">let</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>innerArgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fBound</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span>
      args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>innerArgs<span class="token punctuation">)</span> <span class="token comment">// 拼接参数</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 使用Object.create实现继承</span>
  fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// --测试代码--</span>
<span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person age:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person this:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'ttt'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bindFn <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token function">myBind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'修改'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bindFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//person name: 修改</span>
<span class="token comment">// person age: 12 undefined</span>
<span class="token comment">// person this: { name: 'ttt', age: 12 }</span>

<span class="token function">bindFn</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// person name: 修改</span>
<span class="token comment">// person age: 12 999</span>
<span class="token comment">// person this: { name: 'ttt', age: 12 }</span>

bindFn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// say</span>

<span class="token keyword">const</span> newFn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bindFn</span><span class="token punctuation">(</span><span class="token string">'构造函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// person name: 修改</span>
<span class="token comment">// person age: undefined 构造函数</span>
<span class="token comment">// person this: Person {}</span>
newFn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// say</span>

<span class="token comment">// 普通函数</span>
<span class="token keyword">function</span> <span class="token function">normalFunc</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'普通函数 name'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'普通函数 age'</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'普通函数 this'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bindNormalFunc <span class="token operator">=</span> <span class="token function">normalFunc</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'qqq'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 普通函数 name qqq</span>
<span class="token comment">// 普通函数 age 33</span>
<span class="token comment">// 普通函数 this { name: 'ttt', age: 12 }</span>
<span class="token function">bindNormalFunc</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="q7-new-的过程实现-❓"><a href="#q7-new-的过程实现-❓" class="header-anchor">#</a> Q7.new 的过程实现 ❓</h2> <p>new 关键词的主要作用就是<strong>执行构造函数，返回一个实例对象</strong></p> <h3 id="new-操作符做了哪些事"><a href="#new-操作符做了哪些事" class="header-anchor">#</a> new 操作符做了哪些事</h3> <ul><li><p>以构造器的 prototype 属性为原型（区分私有字段[[prototype]]），创建新对象</p></li> <li><p>将 this 和调用参数传给构造器，执行</p></li> <li><p>如果构造器返回的是对象，则返回，否则返回第一步创建的对象</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个新对象，继承构造函数的原型对象</span>
  <span class="token keyword">let</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 执行构造函数，为新对象添加属性，获取函数执行结果result</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果函数执行结果的返回值类型是对象，则返回执行结果，否则返回新创建的对象</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> result <span class="token operator">:</span> newObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>new 操作符的行为，客观上提供了两种方式添加属性：</p> <p>1️⃣ 在构造器中添加属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>p1 <span class="token operator">=</span> <span class="token string">'构造器的属性'</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">p2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o1<span class="token punctuation">.</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造器的属性</span>
</code></pre></div><p>2️⃣ 在构造器的 <code>prototype</code> 属性上添加属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

c2<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>p1 <span class="token operator">=</span> <span class="token string">'原型的属性'</span><span class="token punctuation">;</span>
c2<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">p2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o2<span class="token punctuation">.</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原型的属性</span>
</code></pre></div><h2 id="q8-module-exports和exports有区别吗-❓"><a href="#q8-module-exports和exports有区别吗-❓" class="header-anchor">#</a> Q8.<code>module.exports</code>和<code>exports</code>有区别吗 ❓</h2> <ul><li><p>在 module 对象中，包含 exports 属性，而我们就是通过这个属性（module.exports），向外暴露(共享)成员的。</p></li> <li><p>在默认情况下，exports 和 module.exports 指向的是同一个对象<code>var exports = module.exports;</code></p></li> <li><p>注意：不能对 exports 直接赋值，这样会导致<code>module.exports</code>和<code>exports</code>指向不同的引用。</p></li></ul> <h2 id="q9-commonjs-和-es-module-中模块化有哪些区别-❓"><a href="#q9-commonjs-和-es-module-中模块化有哪些区别-❓" class="header-anchor">#</a> Q9.commonJS 和 ES Module 中模块化有哪些区别 ❓</h2> <ul><li><p>语法：</p> <ul><li>commonJS 使用<code>require</code>、<code>module.exports</code>和<code>exports</code>关键字。</li> <li>ES Module 使用<code>import</code>和<code>export</code></li></ul></li> <li><p>运行时：</p> <ul><li><p>ESModule 支持异步加载，可以与 import()一起使用，实现代码分割和懒加载。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> importPromise <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./foo.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
importPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>name<span class="token punctuation">,</span> res<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>CommonJS 模块是同步加载的。</p></li></ul></li> <li><p>加载机制：</p> <ul><li>ESModule 是<strong>静态</strong>的，顶层 this 指向 <code>undefined</code>。<strong>import 和 export 必须位于模块的顶层作用域</strong>。ESModule 可以进行静态分析，从而实现树摇（tree shaking）等优化。</li> <li>CommonJS 是<strong>动态</strong>的，顶层 this 指向模块本身。require 可以在代码的任何地方调用，可以根据条件动态加载模块。</li></ul></li></ul> <h2 id="q10-为什么有的编程规范要求用void-0代替undefined❓"><a href="#q10-为什么有的编程规范要求用void-0代替undefined❓" class="header-anchor">#</a> Q10.为什么有的编程规范要求用<code>void 0</code>代替<code>undefined</code>❓</h2> <p>任何变量在赋值前是 <code>Undefined</code> 类型、值为 undefined。在 JS 设计中，<code>undefined</code>不是关键字，而是变量。为避免无意篡改值，建议使用<code>void 0</code>代替<code>undefined</code>值。</p> <p>在实际编程时，可以将变量先赋值为<code>null</code>,<code>null</code>表示：定义了但是为空值。一般不会把变量赋值为 <code>undefined</code>，这样可以保证所有值为<code>undefined</code>的变量，都是从未赋值的自然状态。</p> <h2 id="q11-0-1-0-2-不等于-0-3❓"><a href="#q11-0-1-0-2-不等于-0-3❓" class="header-anchor">#</a> Q11.0.1+0.2 不等于 0.3❓</h2> <p><code>console.log(0.1 + 0.2 == 0.3); // false</code></p> <p>浮点数运算的精度问题导致等式两侧的结果并不是严格相等，正确的比较方法是使用 JS 提供的最小精度值<code>Number.EPSILON</code></p> <p><code>console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); // true</code></p> <h2 id="q12-遍历中如何取到symbol类型-❓"><a href="#q12-遍历中如何取到symbol类型-❓" class="header-anchor">#</a> Q12.遍历中如何取到<code>symbol</code>类型 ❓</h2> <p>常见的对象遍历方法</p> <ul><li><code>for (let xx in obj)</code>：【es5】遍历对象的可枚举属性，包括继承（原型上）的属性，遍历顺序不确定。</li> <li><code>for (let xx of obj)</code>：【es6】遍历可迭代对象(数组、字符串、Set、Map 等)，不会遍历非述职属性或原型上的属性。<strong>如果没有 <code>Iterator</code>接口，无法使用 for of 遍历</strong>。原型部署了 Iterator 接口的数据结构有三种，具体包含四种，分别是数组，类似数组的对象，Set 和 Map 结构。</li> <li><code>Object.keys(obj)</code>：返回包含 key 的数组</li> <li><code>Object.values(obj)</code>：返回包含 value 的数组</li> <li><code>Object.getOwnPropertyNames()</code>：返回包含 key 的数组</li></ul> <p>如何遍历到<code>Symbol</code></p> <ul><li><code>Object.getOwnPropertySymbols()</code>：返回对象中只包含 symbol 类型 key 的数组</li> <li><strong><code>Reflect.ownKeys()</code></strong> ：返回对象中所有类型 key 的数组（包含 symbol）</li></ul> <h2 id="q13-递归遍历实现深拷贝-for-in-❓"><a href="#q13-递归遍历实现深拷贝-for-in-❓" class="header-anchor">#</a> Q13.递归遍历实现深拷贝（for in）❓</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>

  <span class="token keyword">let</span> copyObj <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      copyObj<span class="token punctuation">[</span>obj<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> copyObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q14-为什么给对象添加的方法能用在基本类型上-❓"><a href="#q14-为什么给对象添加的方法能用在基本类型上-❓" class="header-anchor">#</a> Q14.为什么给对象添加的方法能用在基本类型上 ❓</h2> <p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</p> <p>📄<strong>理解装箱转换 &amp; 拆箱转换</strong></p> <p>包装类与原始值转换过程叫做「装箱」和「拆箱」，装箱(boxing)是将值类型包装为对象类型，拆箱(unboxing)是将对象类型转换为类型。</p> <p>每一种基本类型 <code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code> 在对象中都有对应内置的类。装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。</p> <p>装箱操作的<strong>具体步骤</strong>为：创建该类型的实例，在实例上调用指定的方法，销毁实例。</p> <p>拆箱转换：在 JavaScript 标准中，规定了 <code>[Symbol.ToPrimitive]</code> 函数（es6），允许对象通过重写<code>toPrimitive</code> 函数来实现转换（优先级最高）。它是对象类型到基本类型的转换，
如果没有<code>ToPrimitive</code>函数，会先后尝试调用 <code>valueOf</code> 和 <code>toString</code> 来获得拆箱后的基本类型。如果 <code>valueOf</code> 和 <code>toString</code> 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p> <h2 id="q15-手写实现-promise❓"><a href="#q15-手写实现-promise❓" class="header-anchor">#</a> Q15.手写实现 Promise❓</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myPromise</span><span class="token punctuation">(</span><span class="token parameter">constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span> <span class="token comment">// 初始化状态</span>
  self<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 状态为resolved的value</span>
  self<span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 状态为rejected的reason</span>

  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
      self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>
      self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 捕获constructor异常</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义链式调用的then方法</span>
myPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onFullfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'resolved'</span><span class="token operator">:</span>
      <span class="token function">onFullfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'rejected'</span><span class="token operator">:</span>
      <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="q16-load-和-domcontentloaded-有什么区别-❓"><a href="#q16-load-和-domcontentloaded-有什么区别-❓" class="header-anchor">#</a> Q16.Load 和 DOMContentLoaded 有什么区别 ❓</h2> <ul><li>Load 事件触发代表页面中的 DOM ， CSS ， JS ，图片已经全部加载完毕。</li> <li>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS ， JS ，图片加载。</li></ul> <h2 id="q17-重绘和重排有什么区别-如何优化-❓"><a href="#q17-重绘和重排有什么区别-如何优化-❓" class="header-anchor">#</a> Q17.重绘和重排有什么区别，如何优化 ❓</h2> <p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</p> <p>重排是布局或者几何属性需要改变。</p> <p>例如：添加或者删除可见的 DOM 元素; 元素尺寸改变——边距、填充、边框、宽度和高度; 内容变化，比如用户在 input 框中输入文字; 浏览器窗口尺寸改变——resize 事件发生时 计算 offsetWidth 和 offsetHeight 属性等等</p> <p>重排必定发生重绘，重绘不一定引发重排。</p> <p><strong>优化：</strong></p> <ul><li><p>使用 <code>visibility</code> 替换 <code>display:none</code></p></li> <li><p>尽量避免使用 table 布局，table 布局中一个小改动很容易造成 table 的重新布局</p></li> <li><p>css 选择符自右向左匹配查找，避免 dom 深度过深</p></li></ul> <h2 id="q18-网页的加载流程是怎样的-❓"><a href="#q18-网页的加载流程是怎样的-❓" class="header-anchor">#</a> Q18.网页的加载流程是怎样的 ❓</h2> <ul><li>当打开网址时，浏览器会从服务器中获取到 HTML 内容</li> <li>浏览器获取到 HTML 内容后，就开始从上到下解析 HTML 的元素</li> <li><code>head</code>元素内容会先被解析，此时浏览器还没开始渲染页面。
<ul><li><code>head</code>元素里有用于描述页面元数据的 <code>meta</code> 元素，还有一些<code>link</code>元素涉及外部资源(如 图片、css 样式等)，此时浏览器会去获取这些外部资源。<code>head</code>元素中还包含着不少的<code>script</code>元素，这些<code>script</code>元素通过 src 属性指向外部资源</li></ul></li> <li>当浏览器解析到 <code>script</code> 元素时，会暂停解析并下载 JavaScript 脚本</li> <li>当 JavaScript 脚本下载完成后，浏览器的控制权转交给 JavaScript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 HTML 页面</li> <li><code>body</code>元素内容开始被解析，浏览器开始渲染页面</li></ul> <h2 id="q19-性能优化"><a href="#q19-性能优化" class="header-anchor">#</a> Q19.性能优化</h2> <ul><li><p>选择合适的缓存策略</p> <ul><li>强缓存（Expires 和 Cache-Control(优先级高于 Expires)）</li> <li>协商缓存（<code>Last-Modified</code> / <code>If-Modified-Since</code> 或 <code>ETag</code> / <code>If-None-Match</code>）</li> <li>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略
<ul><li>不需要缓存的资源：<code>Cache-control: no-store</code></li> <li>频繁变动的资源：<code>Cache-Control: no-cache</code> + Etag</li></ul></li> <li>对于代码文件，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul></li> <li><p>[preload]预加载：对于不需要立即用到，但是希望尽快获取的资源。预加载即声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件。预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p> <p><code>&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;</code></p></li> <li><p>[prerender]预渲染：将下载的文件预先在后台渲染。
<code>&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot;&gt;</code></p></li> <li><p>对于非首屏的资源，可以使用 defer 或 async 的方式引入</p> <ul><li>[defer]：有顺序依赖</li> <li>[async]：脚本加载完执行</li></ul></li> <li><p>图片懒加载</p></li> <li><p>webpack 优化：</p> <ul><li>使用 es6 模块开启 tree shaking</li> <li>按路由拆分代码，按需加载</li> <li>打包出来的文件添加 hash，实现浏览器缓存文件</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f9c3f30c.js" defer></script><script src="/assets/js/2.b7af9bcd.js" defer></script><script src="/assets/js/1.6eac4c2f.js" defer></script><script src="/assets/js/51.8782a2cd.js" defer></script>
  </body>
</html>
