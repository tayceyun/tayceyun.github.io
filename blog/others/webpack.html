<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概念理解 | tayce&#39;s library</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/logo.jpg">
    <link rel="stylesheet" href="/styles/index.css">
    <meta name="description" content="移动的图书馆">
    
    <link rel="preload" href="/assets/css/0.styles.b67afc4c.css" as="style"><link rel="preload" href="/assets/js/app.f9c3f30c.js" as="script"><link rel="preload" href="/assets/js/2.b7af9bcd.js" as="script"><link rel="preload" href="/assets/js/1.6eac4c2f.js" as="script"><link rel="preload" href="/assets/js/50.0c8a5db9.js" as="script"><link rel="prefetch" href="/assets/js/10.cac3315f.js"><link rel="prefetch" href="/assets/js/11.22aa9600.js"><link rel="prefetch" href="/assets/js/12.2a5384fa.js"><link rel="prefetch" href="/assets/js/13.820e2af8.js"><link rel="prefetch" href="/assets/js/14.11b318eb.js"><link rel="prefetch" href="/assets/js/15.4359e6dc.js"><link rel="prefetch" href="/assets/js/16.42eda455.js"><link rel="prefetch" href="/assets/js/17.3e808b6b.js"><link rel="prefetch" href="/assets/js/18.7130fbcf.js"><link rel="prefetch" href="/assets/js/19.58d29412.js"><link rel="prefetch" href="/assets/js/20.4da7041e.js"><link rel="prefetch" href="/assets/js/21.a6bf00fc.js"><link rel="prefetch" href="/assets/js/22.4de2c7de.js"><link rel="prefetch" href="/assets/js/23.a4fb8c1e.js"><link rel="prefetch" href="/assets/js/24.c3aa6e5e.js"><link rel="prefetch" href="/assets/js/25.519bcaa7.js"><link rel="prefetch" href="/assets/js/26.908b218a.js"><link rel="prefetch" href="/assets/js/27.ead5efbd.js"><link rel="prefetch" href="/assets/js/28.f0099a76.js"><link rel="prefetch" href="/assets/js/29.de5d9f07.js"><link rel="prefetch" href="/assets/js/3.3d769f85.js"><link rel="prefetch" href="/assets/js/30.8a485245.js"><link rel="prefetch" href="/assets/js/31.229bf691.js"><link rel="prefetch" href="/assets/js/32.9bb2b8d8.js"><link rel="prefetch" href="/assets/js/33.41b2fb5b.js"><link rel="prefetch" href="/assets/js/34.7539eb47.js"><link rel="prefetch" href="/assets/js/35.47144861.js"><link rel="prefetch" href="/assets/js/36.3f061274.js"><link rel="prefetch" href="/assets/js/37.c3577050.js"><link rel="prefetch" href="/assets/js/38.78ad621f.js"><link rel="prefetch" href="/assets/js/39.d5eafe9c.js"><link rel="prefetch" href="/assets/js/4.b09b1dd9.js"><link rel="prefetch" href="/assets/js/40.8ce3c438.js"><link rel="prefetch" href="/assets/js/41.0fe59981.js"><link rel="prefetch" href="/assets/js/42.aad61fb2.js"><link rel="prefetch" href="/assets/js/43.6b970b53.js"><link rel="prefetch" href="/assets/js/44.0f85b437.js"><link rel="prefetch" href="/assets/js/45.3f668e4c.js"><link rel="prefetch" href="/assets/js/46.e4f24bc3.js"><link rel="prefetch" href="/assets/js/47.346e64d5.js"><link rel="prefetch" href="/assets/js/48.c4d9666b.js"><link rel="prefetch" href="/assets/js/49.57ec0363.js"><link rel="prefetch" href="/assets/js/5.d2116699.js"><link rel="prefetch" href="/assets/js/51.8782a2cd.js"><link rel="prefetch" href="/assets/js/52.6f1a07d1.js"><link rel="prefetch" href="/assets/js/53.4b57668e.js"><link rel="prefetch" href="/assets/js/54.a926e336.js"><link rel="prefetch" href="/assets/js/55.ea5fe790.js"><link rel="prefetch" href="/assets/js/56.310bbcfd.js"><link rel="prefetch" href="/assets/js/57.6d8b5be5.js"><link rel="prefetch" href="/assets/js/58.ec9d1474.js"><link rel="prefetch" href="/assets/js/59.7fd99801.js"><link rel="prefetch" href="/assets/js/6.dc14cda6.js"><link rel="prefetch" href="/assets/js/60.dcb5d4d7.js"><link rel="prefetch" href="/assets/js/7.c4829e31.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.e1f8ac62.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b67afc4c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tayce's library</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  🏠 Home
</a></div><div class="nav-item"><a href="/blog/linklist/" class="nav-link">
  💬 All
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>概念理解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/others/webpack.html#概念理解" class="sidebar-link">概念理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#术语" class="sidebar-link">术语</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#简化打包原理" class="sidebar-link">简化打包原理</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#打包流程" class="sidebar-link">打包流程</a></li></ul></li><li><a href="/blog/others/webpack.html#常见-loader" class="sidebar-link">常见 loader</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/others/webpack.html#plugin" class="sidebar-link">plugin</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/others/webpack.html#loader-和-plugin-的区别" class="sidebar-link">loader 和 plugin 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/others/webpack.html#热更新" class="sidebar-link">热更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/others/webpack.html#proxy" class="sidebar-link">proxy</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#属性" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#工作原理" class="sidebar-link">工作原理</a></li></ul></li><li><a href="/blog/others/webpack.html#babel-原理" class="sidebar-link">babel 原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#babel-转译的具体过程" class="sidebar-link">babel 转译的具体过程</a></li></ul></li><li><a href="/blog/others/webpack.html#分包" class="sidebar-link">分包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#分包的适用场景" class="sidebar-link">分包的适用场景</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#代码分离-code-splitting" class="sidebar-link">代码分离（Code Splitting）</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#代码分离的方式" class="sidebar-link">代码分离的方式</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#配置打包文件名称-output-chunkfilename" class="sidebar-link">配置打包文件名称 output.chunkFilename</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#分包的预加载-preload-预获取-prefetch" class="sidebar-link">分包的预加载(preload) &amp; 预获取(prefetch)</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#runtime-代码的分包-runtimechunk" class="sidebar-link">runtime 代码的分包（runtimeChunk）</a></li><li class="sidebar-sub-header"><a href="/blog/others/webpack.html#css-文件打包" class="sidebar-link">css 文件打包</a></li></ul></li><li><a href="/blog/others/webpack.html#rollup" class="sidebar-link">Rollup</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="概念理解"><a href="#概念理解" class="header-anchor">#</a> 概念理解</h2> <ul><li>entry:入口。webpack 是基于模块的，使用 webpack 首先需要指定模块解析入口(entry)，webpack 从入口开始根据模块间依赖关系递归解析和处理所有资源文件。</li> <li>output:输出。源代码经过 webpack 处理之后的最终产物。</li> <li>loader:模块转换器。本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</li> <li>plugin :扩展插件。基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li> <li>module:模块。除了 js 范畴内的 es module、commonJs、AMD 等，css @import、url(...)、图片、字体等在 webpack 中都被视为模块。</li></ul> <h3 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h3> <ul><li><p>module:指在模块化编程中我们把应用程序分割成的独立功能的代码模块</p></li> <li><p>chunk:指模块间按照引用关系组合成的代码块，一个 chunk 中可以包含多个 module</p></li> <li><p>chunk group :指通过配置入口点( entry point )区分的块组，一个 chunk group 中可包含一到多个 chunk</p></li> <li><p>bundling:webpack 打包的过程</p></li> <li><p>asset/bundle :打包产物</p></li></ul> <h3 id="简化打包原理"><a href="#简化打包原理" class="header-anchor">#</a> 简化打包原理</h3> <ul><li>一切源代码文件均可通过各种 Loader 转换为 JS 模块 （module）， 模块之间可以互相引用。</li> <li>webpack 通过入口点( entry point )递归处理各模块引用关系，最后输出为一个或多个产物包 js(bundle)文件。</li> <li>每一个入口点都是一个块组( chunk group )，在不考虑分包的情况下，一个 chunk group 中只有一个 chunk , 该 chunk 包含递归分析后的所有模块。每一个 chunk 都有对应的一个打包后的输出文件( asset/bundle)</li></ul> <h3 id="打包流程"><a href="#打包流程" class="header-anchor">#</a> 打包流程</h3> <p><img src="/images/resource/%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt=""></p> <h4 id="简版"><a href="#简版" class="header-anchor">#</a> 简版</h4> <ul><li>Webpack CLI 启动打包流程;</li> <li>载入 Webpack 核心模块，创建 Compiler 对象;</li> <li>使用 Compiler 对象开始编译整个项目;</li> <li>从入口文件开始，解析模块依赖，形成依赖关系树;</li> <li>递归依赖树，将每个模块交给对应的 Loader 处理;</li> <li>合并 Loader 处理完的结果，将打包结果输出到 dist 目录。</li></ul> <h4 id="构建流程核心概念"><a href="#构建流程核心概念" class="header-anchor">#</a> 构建流程核心概念</h4> <p>构建流程核心概念:</p> <ul><li>Tapable:一个基于发布订阅的事件流工具类 <strong>Compiler 和 Compilation 对象都继承于 Tapable</strong>。</li> <li>compiler :webpack 实例，在<strong>编译初始化阶段</strong>被创建，全局唯一，把控整个 webpack 打包的构建流程。包含完整配置信息、 loaders、plugins 以及各种工具方法</li> <li>compilation :编译实例，在 watch 模式下每一次文件变更触发的重新编译都会生成<strong>新的 compilation 对象</strong>，开始一次新的编译。包含了当前编译的模块 module,编译生成的资源，变化的文件,依赖的状态等。同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子。</li> <li>而每个模块间的依赖关系，则依赖于 AST 语法树。每个模块文件在通过 Loader 解析完成之后，会通过 acorn 库生成模块代码的 AST 语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。</li></ul> <p>最终 webpack 打包出来的 bundle 文件是一个 IIFE 的执行函数。</p> <h2 id="常见-loader"><a href="#常见-loader" class="header-anchor">#</a> 常见 loader</h2> <p>Webpack 会按顺序链式调用每个 Loader;遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用。</p> <ul><li>file-loader :加载文件资源，如 字体/图片 等，具有移动/复制/命名等功能</li> <li>url-loader:通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求</li> <li>babel-loader :加载 is/jsx 文件，将 ES6/ES7 代码转换成 ES5，处理兼容性问题;</li> <li>ts-loader:加载 ts/tsx 文件，编译 TypeScript</li> <li>style-loader:将 css 代码以 style 标签的形式插入到 html 中;</li> <li>css-loader:分析@import 和 url()，引用 css 文件与对应的资源</li> <li>postcss-loader:用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等;</li> <li>less-loader / sass-loader :css 预处理器，在 css 中新增了许多语法，提高了开发效率</li></ul> <h2 id="plugin"><a href="#plugin" class="header-anchor">#</a> plugin</h2> <p>在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。</p> <p>plugin 示例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Plugin</span> <span class="token punctuation">{</span>
  <span class="token comment">// 注册插件时，会调用 apply 方法</span>
  <span class="token comment">// apply 方法接收 compiler 对象</span>
  <span class="token comment">// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// compilation 是监听每次编译循环</span>
    <span class="token comment">// 每次文件变化，都会生成新的 compilation 对象并触发该事件</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'compilation'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注册插件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span>export <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Plugin</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>常用的 Plugin</p> <ul><li>UglifyJsPlugin:压缩、混淆代码（在生产环境中删除不可能被执行的代码）</li> <li>CommonsChunkPlugin:代码分割</li> <li>ProvidePlugin: 自动加载模块</li> <li>DefinePlugin:定义全局变量</li> <li>html-webpack-plugin:自动创建一个 HTML 文件，并把打包好的 JS 插入到 HTML 文件中</li> <li>extract-text-webpack-plugin/mini-css-extract-plugin: 抽离 CSS 代码，放到一个单独的文件中;</li> <li>optimize-css-assets-webpack-plugin: Css 代码去重，压缩 css</li> <li>webpack-bundle-analyzer: 代码分析</li> <li>compression-webpack-plugin:使用 gzip 压缩 js 和 css</li> <li>happypack: 使用多进程，加速代码构建</li> <li>EnvironmentPlugin: 定义环境变量</li> <li>clean-webpack-plugin 在每一次打包之前，删除整个输出文件夹下所有的内容</li></ul> <h2 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="header-anchor">#</a> loader 和 plugin 的区别</h2> <ul><li>loader 就是模块转换化，或叫加载器。不同的文件，需要不同的 loader 来处 理。</li> <li>plugin 是插件，可以参与到整个 webpack 打包的流程中，不同的插件，在合适的时机，可以做不同的事件。</li></ul> <h2 id="热更新"><a href="#热更新" class="header-anchor">#</a> 热更新</h2> <p><img src="/images/webpack/hmr.png" alt=""></p> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> proxy</h2> <p>接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)
想要实现代理首先需要一个中间服务器， webpack 中提供服务器的工具为 webpack-dev-server</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <ul><li>target:表示的是代理到的目标地址</li> <li>pathRewrite:默认情况下， /api 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite</li> <li>secure:默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false</li> <li>changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">contentBase</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">compress</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">9000</span><span class="token punctuation">,</span>
    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'https://api.github.com'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h3> <p>proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器。</p> <p>通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者。当本地发送请求的时候，<strong>代理服务器</strong>响应请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  <span class="token string">'/api'</span><span class="token punctuation">,</span>
  <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'http://www.example.org'</span><span class="token punctuation">,</span> <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span>
</code></pre></div><h2 id="babel-原理"><a href="#babel-原理" class="header-anchor">#</a> babel 原理</h2> <p>babel 编译的三个阶段:parsing、 transforming、generating.</p> <h3 id="babel-转译的具体过程"><a href="#babel-转译的具体过程" class="header-anchor">#</a> babel 转译的具体过程</h3> <p>ES6 代码输入 ==》 babylon 进行解析 ==》 得到 AST ==》 plugin 用 babel-traverse 对 AST 树进行遍历转译 ==》 得到新的 AST 树 ==》 用 babel-generator 通过 AST 树生成 ES5 代码</p> <p>限制：babel 只是转译新标准引入的语法，比如 ES6 的箭头函数转译成 ES5 的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的 API 等（如 Proxy、Set 等），这些 babel 是<strong>不会转译</strong>的。需要用户自行引入 <strong>polyfill</strong> 来解决</p> <h2 id="分包"><a href="#分包" class="header-anchor">#</a> 分包</h2> <h3 id="分包的适用场景"><a href="#分包的适用场景" class="header-anchor">#</a> 分包的适用场景</h3> <p>默认情况下，Webpack 会将所有代码构建成一个单独的包。包体积逐步增长可能会导致应用的响应耗时越来越长。将所有资源打包成一个文件的方式存在两个弊端：</p> <ul><li>资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码</li> <li>缓存失效：将所有资源达成一个包后，即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低。</li></ul> <h3 id="代码分离-code-splitting"><a href="#代码分离-code-splitting" class="header-anchor">#</a> 代码分离（Code Splitting）</h3> <ul><li>代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件； 比如默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载， 就会影响首页的加载速度；</li> <li>代码分离可以分出出更小的 bundle，以及控制资源加载优先级，提供代码的加载性能；</li></ul> <p>例如 node_modules 中的资源通常变动较少，可以抽成一个独立的包。</p> <h3 id="代码分离的方式"><a href="#代码分离的方式" class="header-anchor">#</a> 代码分离的方式</h3> <ul><li>入口起点：使用 entry 配置手动分离代码；</li></ul> <p>配置多入口 &amp; 共享文件共同的依赖库</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">main</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span> <span class="token literal-property property">dependOn</span><span class="token operator">:</span> <span class="token string">'shared'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 第一个入口起点</span>
    <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span> <span class="token literal-property property">dependOn</span><span class="token operator">:</span> <span class="token string">'shared'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 第二个入口起点</span>
    <span class="token literal-property property">shared</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'dayjs'</span><span class="token punctuation">,</span> <span class="token string">'lodash'</span><span class="token punctuation">]</span> <span class="token comment">// 共享的库</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span><span class="token punctuation">,</span> <span class="token comment">// 使用[name]占位符将生成的文件名与入口起点名称对应</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>防止重复：使用 Entry Dependencies 或者 SplitChunksPlugin 去重和分离代码；</p> <p>SplitChunksPlugin 插件可以将应用程序中共享的代码拆分成单独的块，以便将其从应用程序代码中分离出来，从而提高性能和加载速度。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">splitChunks</span><span class="token operator">:</span> <span class="token punctuation">{</span>
	  <span class="token comment">// async：拆分异步导入模块</span>
	  <span class="token comment">// initial：拆分同步导入模块</span>
	  <span class="token comment">// all:拆分所有模块</span>
      <span class="token literal-property property">chunks</span><span class="token operator">:</span> <span class="token string">'async'</span><span class="token punctuation">,</span>
	  <span class="token comment">// 拆分包的最小尺寸</span>
      <span class="token literal-property property">minSize</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>
      <span class="token literal-property property">minRemainingSize</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
	  <span class="token comment">// 至少被引入次数</span>
      <span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
	  <span class="token comment">// 最大的初始化请求数量</span>
      <span class="token literal-property property">maxAsyncRequests</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
      <span class="token literal-property property">maxInitialRequests</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
      <span class="token literal-property property">enforceSizeThreshold</span><span class="token operator">:</span> <span class="token number">50000</span><span class="token punctuation">,</span>
	  <span class="token comment">// 对拆分的包进行分组</span>
      <span class="token literal-property property">cacheGroups</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">defaultVendors</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		  <span class="token comment">// 匹配符合规则的包</span>
          <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\/]node_modules[\\/]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
		  <span class="token comment">// 一个模块可以属于多个cacheGroups。优化将优先考虑具有更高 priority（优先级）的cacheGroups。默认组的优先级为负，自定义组的默认值为 0;</span>
          <span class="token literal-property property">priority</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>
		  <span class="token comment">// 拆分包的name属性</span>
          <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">''</span><span class="token punctuation">,</span>
		  <span class="token comment">// 拆分包的名称</span>
          <span class="token literal-property property">fileName</span><span class="token operator">:</span> <span class="token string">'vender_[id]_[name].js'</span>， <span class="token comment">//打包之后的文件名</span>
		  <span class="token comment">// 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块。这可能会影响 chunk 的结果文件名;</span>
          <span class="token literal-property property">reuseExistingChunk</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
          <span class="token literal-property property">priority</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>
          <span class="token literal-property property">reuseExistingChunk</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>动态导入（ES6 的 import()语法）：通过模块的内联函数调用来分离代码</li></ul> <p>当代码中存在不确定会被使用的模块时，最佳做法是将其分离为一个独立的 JavaScript 文件。这样可以确保在不需要该模块时，浏览器不会加载或处理该文件的 JavaScript 代码。</p> <p>动态导入也是路由懒加载的原理，都是为了优化性能而延迟加载资源。</p> <div class="language-js extra-class"><pre class="language-js"><code>homeBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="token string">'./views/home.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 魔法注释</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="配置打包文件名称-output-chunkfilename"><a href="#配置打包文件名称-output-chunkfilename" class="header-anchor">#</a> 配置打包文件名称 <code>output.chunkFilename</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">chunkFilename</span><span class="token operator">:</span> <span class="token string">'chunk_[name]_[id].js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="分包的预加载-preload-预获取-prefetch"><a href="#分包的预加载-preload-预获取-prefetch" class="header-anchor">#</a> 分包的预加载(preload) &amp; 预获取(prefetch)</h3> <ul><li>preload</li></ul> <p>preload 是告诉浏览器预先请求当前页面需要的资源，通常是当前页面渲染所必需的关键资源，如字体、样式表或脚本。它会在<strong>当前页面加载时立即开始加载</strong>，而不需要等待解析完 js 或者 css 之后再去加载对应的资源。与浏览器的空闲状态不相关。因此，preload <strong>可能会影响初始页面加载性能</strong>，因为它可以竞争主要资源的带宽。</p> <p><code>import(/* webpackPreload: true */ './view/about');</code></p> <ul><li>prefetch</li></ul> <p>在浏览器空闲时，即浏览器已经加载主要资源并且有剩余带宽时开始加载。这意味着 prefetch <strong>不会影响初始页面加载时间</strong>，因为它是在<strong>后台加载</strong>的。通常用于加载将来可能需要的资源，例如懒加载的代码块或其他不太紧急的资源。</p> <p><code>import(/* webpackPrefetch: true */ './view/home')</code></p> <h3 id="runtime-代码的分包-runtimechunk"><a href="#runtime-代码的分包-runtimechunk" class="header-anchor">#</a> runtime 代码的分包（runtimeChunk）</h3> <p>配置 runtime 相关的代码是否抽取到一个单独的 chunk 中：</p> <ul><li>runtime 相关的代码指的是在运行环境中，对模块进行解析、加载、模块信息相关的代码；</li> <li>例如 component、bar 两个通过 import 函数相关的代码加载，就是通过 runtime 代码完成的；</li></ul> <p>runtime 抽离出来后，有利于浏览器的缓存策略：</p> <ul><li>例如修改了业务代码（main），那么 runtime 和 component、bar 的 chunk 是不需要重新加载的；</li> <li>例如修改了 component、bar 的代码，那么 main 中的代码是不需要重新加载的；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">runtimeChunk</span><span class="token operator">:</span> <span class="token string">'true/multiple'</span> <span class="token comment">//针对每个入口打包一个runtime文件</span>
    <span class="token literal-property property">runtimeChunk</span><span class="token operator">:</span> <span class="token string">'single'</span>  <span class="token comment">//打包一个runtime文件</span>
    <span class="token literal-property property">runtimeChunk</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">name</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">entrypoint</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>entrypoint<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token comment">// 决定runtimeChunk的名称</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="css-文件打包"><a href="#css-文件打包" class="header-anchor">#</a> css 文件打包</h3> <p>常规的配置<code>css-loader</code>和<code>style-loader</code>,最终会把 css 注入到页面中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token comment">//通过正则告诉webpack匹配是什么文件</span>
        <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token comment">//  loader的执行顺序是从右向左，style-loader在css-loader前面；</span>
          <span class="token punctuation">{</span> <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'style-loader'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span> <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'css-loader'</span> <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="将-css-提取到独立-css-文件中-minicssextractplugin"><a href="#将-css-提取到独立-css-文件中-minicssextractplugin" class="header-anchor">#</a> 将 css 提取到独立 css 文件中（MiniCssExtractPlugin）</h4> <p>优势：1️⃣ 分离结构和样式，使代码更加模块化和易于维护。2️⃣（缓存优化）独立的 CSS 文件可以被浏览器缓存，当用户再次访问网站时，可以减少加载时间，提高性能。</p> <p>安装：<code>npm install mini-css-extract-plugin -D</code></p> <p>配置 rules 和 plugins：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token comment">// 将CSS样式提取为单独的CSS文件，通过链接方式(link)引入到HTML中</span>
          <span class="token punctuation">{</span> <span class="token literal-property property">loader</span><span class="token operator">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span> <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'css-loader'</span> <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 使用MiniCssExtractPlugin插件</span>
      <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'css/[name]_[id].css'</span><span class="token punctuation">,</span> <span class="token comment">// 打包后的css文件放到css文件夹中</span>
      <span class="token literal-property property">chunkFilename</span><span class="token operator">:</span> <span class="token string">'css/[name]_[id].css'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="rollup"><a href="#rollup" class="header-anchor">#</a> Rollup</h2> <p>Rollup 是一款 ES Modules 打包器。它也可以将项 目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p> <p>优势：</p> <ul><li>输出结果更加扁平，执行效率更高;</li> <li>自动移除未引用代码;</li> <li>打包结果依然完全可读。</li></ul> <p>缺点：</p> <ul><li>加载非 ESM 的第三方模块比较复杂;</li> <li>因为模块最终都被打包到全局中，所以无法实现 HMR ;</li> <li>浏览器环境中，代码拆分功能必须使用 Require.js 这样的 AMD 库</li></ul> <p>实践：
如果应用程序开发，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</p> <p>如果是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack。</p> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f9c3f30c.js" defer></script><script src="/assets/js/2.b7af9bcd.js" defer></script><script src="/assets/js/1.6eac4c2f.js" defer></script><script src="/assets/js/50.0c8a5db9.js" defer></script>
  </body>
</html>
