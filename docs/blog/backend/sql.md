## SQL

### 按功能划分 SQL 语言

1. DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。
2. DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。
3. DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。
4. DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道。因此学会编写正确且高效的查询语句，是学习的重点。

### 了解 SQL

SQL 是我们与 DBMS 交流的语言，我们在创建 DBMS(Database Management System:数据库管理系统) 之前，还需要对它进行设计，对于 RDBMS（Relational Database Management System:关系数据库管理系统） 来说采用的是 ER 图（Entity Relationship Diagram），即实体 - 关系图的方式进行设计。

ER 图评审通过后，我们再用 SQL 语句或者可视化管理工具（如 Navicat）创建数据表。

实体 - 关系图有什么用呢？它是我们用来描述现实世界的概念模型，在这个模型中有 3 个
要素：实体、属性、关系。实体就是我们要管理的对象，属性是标识每个实体的属性，关系则是对象之间的关系。

创建完数据表之后，我们就可以用 SQL 操作了。

SQL 推荐采用统一的书写规范：

1. 表名、表别名、字段名、字段别名等小写；
2. SQL 保留字、函数名、绑定变量等大写。
3. 数据表的字段名推荐采用下划线命名，如 role_main。

### SQL 是如何被执行的

#### Oracle 中的 SQL 是如何执行的，什么是硬解析和软解析？

![](/images/backend/sql执行过程.png)

1. 语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。
1. 语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。
1. 权限检查：看用户是否具备访问该数据的权限。
1. 共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是**缓存 SQL 语句和该语句的执行计划**。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。
1. 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。
1. 执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。

库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。

查询 ID：`SQL> select * from player where player_id = 10001;`

绑定变量：`SQL> select * from player where player_id = :player_id;`

这两个查询语句的效率在 Oracle 中是完全不同的。如果在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行划,也就是软解析。

#### MySQL 中的 SQL 是如何执行的，MySQL 的体系结构又是怎样的？

MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：

![](/images/backend/mySql.png)

MySQL 由三层组成：

1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；
2. SQL 层：对 SQL 语句进行查询处理；
3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。

❓ 在 MySQL 中对一条 SQL 语句的执行时间进行分析

1. 开启 profiling,0 代表关闭，1 为开启：`mysql> select @@profiling;`;`mysql> set profiling=1;`

2. 执行 SQL 查询：`mysql> select * from wucai.heros;`

3. 查看会话产生的所有 profiles：`show profiles;`
   或查询指定的 Query ID：`mysql> show profile for query 2;`

#### 什么是存储引擎，MySQL 的存储引擎都有哪些？

与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：

1. InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。
2. MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。
3. Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。
4. NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。
5. Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。

### DDL

#### DDL 定义了数据库的结构和数据表的结构

##### 了解 DDL 的基础语法

在执行 DDL 的时候，不需要 COMMIT，就可以完成执行任务。

增删改:`CREATE`,`DROP`,`ALTER`

1️⃣ 定义数据库

创建一个名为 nba 的数据库：`CREATE DATABASE nba;`

删除一个名为 nba 的数据库：`DROP DATABASE nba;`

2️⃣ 定义数据表

创建表结构：`CREATE TABLE table_name`

创建示例：

```
CREATE TABLE player (
player_id int(11) NOT NULL AUTO_INCREMENT,
player_name varchar(255) NOT NULL
);
```

解释：创建一个表名为 player 的表，，里面有两个字段，一个是 player_id，它是 int 类型，另一个 player_name 字段是 varchar(255)类型。这两个字段都不为空，且 player_id 是递增的。

`int(11)`：整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度

`varchar(255)`：最大长度为 255 的可变字符串类型

`NOT NULL`：整个字段不能是空值，是一种数据约束

`AUTO_INCREMENT`：主键自动增长

实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具**（Navicat）**来创建和操作数据库和数据表。

3️⃣ 修改表结构

在创建表结构之后，我们还可以对表结构进行修改，虽然直接使用 Navicat 可以保证重新导出的数据表就是最新的，但也有必要了解如何使用 DDL 命令来完成表结构的修改。

添加字段(age 字段)：`ALTER TABLE player ADD (age int(11));`

【❓ 存疑】修改字段名(player--> player_age)：`ALTER TABLE player RENAME COLUMN age to player_age`

修改字段数据类型(player_age 数据类型-->float(3,1))：`ALTER TABLE player MODIFY (player_age float(3,1));`

删除字段(player_age)：`ALTER TABLE player DROP COLUMN player_age;`

#### 使用 DDL 定义数据表时，都有哪些约束性

1️⃣ 主键约束

主键起的作用是唯一标识一条记录，不能重复，不能为空，即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。

2️⃣ 外键约束

外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。

【示例】：player_id 在 player 表中是主键，如果想设置一个球员比分表即 player_score，就可以在 player_score 中设 player_id 为外键，关联到 player 表中。

3️⃣ 字段约束

- 唯一性约束：唯一性约束表明字段在表中的数值是唯一的。唯一性约束和普通索引（NORMAL INDEX）之间是有区别的。唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。
- NOT NULL 约束：表明该字段不应为空，必须有取值。
- DEFAULT：表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。
- CHECK 约束：检查特定字段取值范围的有效性，CHECK 约束的结果不能为 FALSE。

#### 使用 DDL 设计数据库时，都有哪些重要原则

- 数据表的个数越少越好。RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图（Entity Relationship Diagram），数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。
- 数据表中的字段个数越少越好。字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。
- 数据表中联合主键的字段个数越少越好。设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。
-

### SQL 检索数据
